# L2.1 â€“ JavaScript Functions & Arrays

## 2.1.1 Function Pointers and Closures
- Functions are first-class values: assign them to variables, store in arrays, pass to other functions.
- A closure forms when an inner function captures variables from its outer scope, keeping them alive even after the outer function returns.

```js
function makeCounter(start = 0) {
  let count = start;
  return function increment() {
    count += 1;
    return count;
  };
}

const counter = makeCounter(5);
counter(); // 6
counter(); // 7 â€“ closure keeps `count` private
```

## 2.1.2 Functions as Objects
- Every function is an object: it can have properties and methods like any other object.
- Built-in properties include `name`, `length`, and `prototype` (for constructor functions).
- You may attach custom metadata or helpers directly on a function.

```js
function greet(name) {
  return `Hello ${name}`;
}

greet.description = "Outputs a friendly greeting";

console.log(greet.name); // "greet"
console.log(greet.description); // "Outputs a friendly greeting"
```

## 2.1.3 Hoisting and Arrays
- Hoisting moves declarations (not initialisations) to the top of their scope during compilation.
  - Function declarations hoist fully; you can call them before they appear.
  - `var` variables hoist as `undefined`; `let`/`const` stay in the temporal dead zone until declared.
- Arrays often combine with hoisting when organising utility functions or callbacks.

```js
showFirst(); // works: function declaration hoisted

function showFirst() {
  const numbers = [3, 1, 4];
  console.log(numbers[0]);
}

console.log(total); // undefined: `var` hoists without value
var total = [3, 1, 4].reduce((sum, n) => sum + n, 0);
```
