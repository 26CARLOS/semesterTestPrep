# L2.2 â€“ ES6 Essentials

## 2.2.1 What is ES6
- ECMAScript 2015 (ES6) introduced modern JavaScript features that improve readability, modularity, and developer ergonomics.
- Key themes: block scoping, concise syntax, better object handling, and built-in utilities for asynchronous and modular code.

## 2.2.2 Variable Declarations, Template Strings, and Default Parameters
- `let` and `const` provide block-scoped bindings; prefer `const` unless reassignment is required.
- Template literals support interpolation and multiline strings using backticks.
- Functions can declare default parameter values to avoid manual fallback logic.

```js
const user = "Lerato";
let mood = "excited";
const message = `Hey ${user}, feeling ${mood}?`;

function greet(name = "friend") {
  return `Hello ${name}!`;
}
```

## 2.2.3 Arrow Functions
- Arrow functions offer concise function syntax and lexically bind `this`.
- Useful for callbacks and inline computations; avoid when a named function or `this` rebinding is required.

```js
const numbers = [1, 2, 3];
const squares = numbers.map(n => n * n);
const counter = {
  value: 0,
  incrLater() {
    setTimeout(() => {
      this.value += 1; // `this` refers to counter
    }, 1000);
  }
};
```

## 2.2.4 Destructuring and Object Literal Enhancement
- Destructuring extracts values from arrays or objects into clear bindings.
- Object literal enhancement allows property shorthand and method definitions.

```js
const userData = { id: 5, name: "Jabu", city: "Pretoria" };
const { id, name } = userData; // destructuring

const score = 42;
const summary = { id, name, score, display() { return `${name}: ${score}`; } };
```

## 2.2.5 Spread Operator
- Spread (`...`) clones arrays/objects and merges collections.
- Rest parameters collect remaining arguments into an array.

```js
const base = [1, 2];
const extended = [...base, 3, 4];

const settings = { theme: "light" };
const userSettings = { ...settings, theme: "dark" };

function logAll(first, ...rest) {
  console.log(first, rest);
}
```

## 2.2.6 JS OOP
- ES6 class syntax wraps prototype-based inheritance in a familiar pattern.
- `constructor` runs on instantiation; `extends` enables inheritance; `super` accesses parent constructors/methods.

```js
class Person {
  constructor(name) {
    this.name = name;
  }
  introduce() {
    return `Hi, I'm ${this.name}`;
  }
}

class Student extends Person {
  constructor(name, course) {
    super(name);
    this.course = course;
  }
  introduce() {
    return `${super.introduce()} and I study ${this.course}.`;
  }
}
```
